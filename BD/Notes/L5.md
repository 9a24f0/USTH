# Functional dependency (FD)
- a constraint btwn 2 sets of attr
- X: determinant set, Y: dependent attr
- notation: X -> Y in R
- convention: X,Y,Z represent sets; A,B,C represent single attr
- if Y is subset of X, X -> Y is **trivial** depedency
- right side rule: A -> BCD; A -> B, A -> C, A -> D

# FD example
Drinkers (name, addr, beerLiked, manf, favBeer)
1. name -> addr favBeer (equivalent with name -> addr and name -> favBeer)
2. beerLiked -> manf

# Properties of func dependencies
- subset property: Y is subset of X, X -> Y
- augmentation: X -> Y, X|Z -> Y|Z
- transitivity: X -> Y, Y -> Z then X -> Z
- union: X -> Y, X -> Z then X -> Y\capZ
- decomposition: X -> YZ, then X -> Y and X -> Z
- pseudo transivity: X -> Y and YZ -> W, the XZ -> W
- extension: X -> Y and W -> Z, the WX -> YZ

# Keys (remind)
A set of 1+ attr K = {K_i} is key if
1. those attr functionally determine all other attr of R
2. no proper subset of K determine all other attr of R

# Super-cle
A set of attr that contains a key

# Closure set
X is a set of attr, S is set of FDs
- the closure of X under S is the set of attr Y such X -> Y using S
- annotation: closure of X denoted by X+

# Closure set example:
- R = (A, B, C, D, E, F)<br>
S = {A -> C, A -> D, D -> E, E -> F}<br>
{A}+ = {A, C, D, E, D}

- R = (A, B, C, D, E, F)<br>
S = {AB -> C, BC -> AD, D -> E, CF -> B}<br>
{AB}+ = (A, B, C, D, E)

- R = (A, B, C, D)<br>
S = {BC -> D, D -> A, A -> B} <br>
{BC}+ = (B,C,D,A)<br>
Thus, {BC}+ is a key

- R = (A, B, C, D)<br>
S = {A -> B, A -> C, C -> D}<br>
{A}+ = (A, B, C, D)

# Normal form
I found a really nice explanation of normal forms [here](https://www.youtube.com/watch?v=ABwD8IYByfk.)

## Anormalies
 **Def'n**: redundancy occur when cramming too much into 1 relation

### Types
- redundancy: info repeated unnecessary
- update anomalies: change info 1 place and keep other info the same
- delete anomalies: if a set of values become empty, we may lose info

### Solution

#### Decomposition
- splitting attributes of R -> schemas of 2 new relations
- def'n: R(A1, A2,... An) is decomposed to S(B1, B2,...Bm) and T(C1, C2,... Ck) if
  - {A1, A2,..An} = {B1 ,..,Bm} U {C1,..Ck}
  - S = ∏ B1,..Bm (R)
  - T = ∏ C1,..,Ck (R)
- dis:
    - we might cant recovery the original info
    - after reconstruction, FDs may not hold

#### 1NF
- Def'n: att must be sigle value, atomic
- tuple: unique
- e.g:

| item       | color  | price | tax  |
|------------|--------|-------|------|
| T-shirt    | red    | 12.00 | 0.60 |
| T-shirt    | blue   | 12.00 | 0.60 |
| polo       | red    | 12.00 | 0.60 |
| polo       | yellow | 12.00 | 0.60 |
| sweatshirt | blue   | 25.00 | 1.25 |
| sweatshirt | black  | 25.00 | 1.25 |

#### 2NF
- Def'n: non-PK key attr depends on all comp of PK

E.g: Products (*item*, *color*, price, tax)

Since `price` and `tax` not depends on `color` -> not 2NF

Sol: Split to: products(*item*, *color*) and price(*item*, price, tax)

#### 3NF
- Def'n: non-key attr depends on others

E.g: Products (*item*, price, tax)

Since `price` depends on `tax` -> not 3NF

Sol: split to: products(*item*, price) and tax(*price* , tax)

#### Exercises
- R (A, B, C, D, E, F)<br>
S = {AB -> C, BC -> AD, D -> E, CF -> B}<br>
keys: CF <br>
primary attr: C, F<br>
AB -> C: AB is not a key, C is a primary attribute, violates 3NF
- R (A, B, C, D) <br>
S = {BC -> D, D -> A, A -> B}<br>
keys: AC, BC, DC<br>
primary attribute: A, B, C, D <br>
D -> A: D is not a key, D is a primary attribute -> violates 3NF
- R (A, B, C, D)<br>
S = {A -> B, A -> C, C -> D}<br>
keys: A<br>
primary attribute: A<br>
since B,C,D are not primary attribute, all 3 FDs does not violate 3NF
- R (A, B, C, D)<br>
S = {A -> B, B -> C, C -> D, D -> A}<br>
keys: A, B, C, D<br>
since A,B,C,D are all keys, all 4 FDs does not violate 3NF
- R (A, B, C, D)<br>
S = {AD -> B, AB -> C, BC -> D, CD -> A}<br>
keys: AD, AB, BC, CD<br>
since AD, AB, BC, CD are all keys, all 4 FDs does not violate 3NF